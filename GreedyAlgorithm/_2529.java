package GreedyAlgorithm;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Collection;
import java.util.Collections;



/*
가장 큰숫자는   9876543210
가장 작은숫자느 1234567890 이다.
그렇다면 여기서 우리가 알아야할 사실은 어쨋든 간에 그리드 알고리즘의 핵심은 무조건적으로 옳은길로만 가면 된다는것이다.

9 < 8 < 7 < 6 > 5 < 4 < 3 > 2 < 1 > 0
이렇게 되어있을때 일단 다 987654321을 집어넣고 생각해보자.
9   8   7   7   4       4   1   2   0
  <   <   <   >   >   <   >   <   >
우선 여기서 최댓값은
6 < 7 < 8 < 9 > 3 < 4 < 5 > 1 < 2 > 0 이다.
같은 부분은 4밖에없다.
규칙을 파악해보면 < 에서는 역순으로 동작하는것 같고 > 에서는 역순으로 동작하고 나머지 숫자가 진행되는걸로 알수있다.
너무 복잡한것을 알수있다.
<<<<<<
><<<>
<><<<>>
><><<
<
>>
><<><><>
>><>
어떠한 모든방법에서 최댓값을 구한다고 파악해보면은
각 특성에 맞게 계산해야되서
9876543210 에서
0123456789 으로 될경우 <<<<<<<< 어떻게 해야 저렇게 바뀔수 있을까? 
<<<<<< 일경우에 오름차순이다.
>>>>>> 일경우에 내림차순이다. 그냥 답이 그대로다.
그렇다고한다면 <<<<><<<< 이런경우에서는 어떻게 계산을 할까
9876543210
9999999999
<>에서는 1을 더하고 ><에서는 1을 빼라
<<<<><<<<
01234 56789
01235 46789  
 > > > > < > > > > 
9 8 7 6 4 5 3 2 1 0



최솟값일때는
0123456789를 넣고
 


*/
/*
가장 큰 숫자와 가장 작은숫자

    <  <  <  >  <  <  >  <  >
   9  8  7  6  5  4  3  2  1  0
   0  1  2  3  4  5  6  7  8  9
  0   1   2   3   4   5   6   7   8   9
  0 < 1 < 2 < 4 > 3 < 5 < 7 > 6 < 9 > 8

   6  7  8  9  3  4  5  1  2  0
  0   1   2   3   4   5   6   7   8   9
  0 < 1 < 2 < 4 > 3 < 5 < 7 > 6 < 9 > 8

0 1 2 3 4 5 6 7 8  
>0<3>2<5>4<7>6<
채우고 남은숫자는오름차순으로 
오름차순일때
 <> 일때 +1
 >< 일때 -1
   
9   8   7   6   5   4   3   2   1   0
6 < 7 < 8 < 9 > 3 < 4 < 5 > 1 < 2 > 0  // 

1) 부등호가 하나
9   8
'<'
8 < 9 (바꾸기)
0 < 1 (그대로)
'>' 
9 > 8 (그대로)
1 > 0 (바꾸기)

2) 부등호가 두개
'<<'
987
789 (역순으로)
'<>'
987 
8 9 7 
012
021 
'>>'
987
987
012
102
120  부호성립이 안됨
 
'><'

6 7 8 9 4 5 2
3  1  0
규칙을 찾아야한다.. 밑에 규칙은 너무 까다롭다.
그리디알고리즘은 최적에서 계산만하면 되는것이다.
if문으로 전부다 계산하고 정렬하면 되지 않을까 싶지만 이것이 답은 아닐것이다.
< 는 + 1 씩 증가

 < < 사이에서 찾는다고 생각해보면   
  오름차순은 찾았는데 내림차순은 
3   1  -1  -3   2   0  -2   1  -1   0
// 

우선 가장 큰숫자라는것은 9876543210이고
            <<<><<><>
     가장 작은숫자라는   0123456789이다.
    
부등호를 만족시키기위해서는
 < > > < < > < > >
0
0 1
0 2 1
0 3 2 1
0 3 2 1 4
0 3 2 1 4 5
0 3 2 1 4 6 5

가장 큰 숫자일때)
     '<' 일때는 9876을 역순으로 할경우는 6 < 7 < 8 < 9 > 3 < 4 < 5 > 1 < 2 > 0 
     < 일때는 오름역순으로 순서대로 넣고 > 일때는 다음 > 가 나올때까지 기다렸다가 5 에서 2 빼서 순서대로 > 까지 넣고 그리고 2넣고 다시 > 나올때까지 기다렸다가 1
가장 작은 숫자일때)
    '<' 일때는 '>'을 찾을때까지 기달리다가 찾으면 
    1 < 2 < 3 < 4 >  < < > < >    


    결국은 정답을 찾는것이다.
    9 8 7 6 5 4 3 2 1 0 여기서 어떻게 조작을 하여서 저식에 넣을수 있을까?
    그것이 해결책의 시작인다
     < < < > < < > < > 여기에다가 넣었을때
     <> >< 이 모양을 찾으면 
     > > > < > > < > <
          5 6   2 3 0 1
    9 8 7 6 5 4 3 2 1 0

    중요한것은 < 부분이다.
    <를 찾고선 12356789 
    <를 찾고선 1 4 67 8 이렇게 찾았다 치면은
    만약에 이것을 식별가능하다면 연속된것인지 안된것인지 식별가능한방법을 찾았다하면은
    해당부분에서 연속된 부분 : A
    해당숫자에서 - A+1 를 하고선 이거아무리 생각해도 너무복잡하다.
    통합적인 방법이 필요함 다른방법
    찾은부분에서 
    

     < < < > < < > < >  
    6 7 8 9 3 4 5 1 2 0
    1) 시작을 9 8 7 6 5 4 3 2 1 0 
    2) 다 집어넣고 < 부분만 검사하면된다.
    3) <이 0 1 2 에 걸쳐서 3개니까 0~3까지 6789 4개
    4) <이 4 5 에 걸쳐서 2개니까 4에서 6까지  345 3개

    <을 찾으면 
    

       > > < > > < > < >
      9 8 7 6 5 4 3 2 1 0
      9 8 6 7 5 3 4 1 2 0
    1) < 의 갯수만큼 역순
    2)    6 7   3 4 1 2

    0 1 2

    <의 갯수와 <가 끝나는 다음항 저기서는 3이니가 [3] 까지 9876
    <의 갯수 2개 


    

*/



public class _2529 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        

    }
    
    
}